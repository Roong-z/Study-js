`	`var/const/let ?

`	`var 재선언/재할당 가능

`	`var 키워드로 선언한 변수는 블록스코프를 무시하고 스코프 울타리 밖에서도 접근할수 있다!(var는 only 함수 스코프만 따른다.)

`	`var 키워드로 변수를 선언하면 window 객체에 속해진다. window.변수 로 확인

`	`let 재선언가능/재할당불가능

`	`const 재선언/재할당 불가능

1. `	`페인트공 알고리즘



`	`첫날에 300야드를 칠하고 다음날 150 그리고 셋째날 30야드를 칠하는 페인트공의 슬픈이야기

`	`"매일 페인트 통에서 멀어지기 때문에 칠하는 범위가 떨어진다."

`	`= "일단 작동은 잘하는 코드지만 기술의 부족,확장성 부족등으로 개발 범위가 커지면 효율이 떨어지는 날코딩"

`	`char string[1000];

`	`strcpy(string, "one");

`	`strcat(string, ", two");

`	`strcat(string, ", three");

`	`strcat(string, ", four");

`	`void strcat(char \* dest, char \* src)

`	`{

`	`while (\*dest) dest++;

`	`while (\*dest++ = \*src++);

`	`}

`	`수정본

`	`char \*strcat(char \*dest, char \*src)

`	`{

`	`while(\*dest) dest++;

`	`while(\*dest++ = \*src++);

`	`return --dest;

`	`}

`	`=> 이해한 바로는 문자열을 찾아서 연결하고 리턴하는건데 문자열이 null값이 나올때까지 처음부터 끝까지 계속 달려가는 비효율적인 코드?

`	`이런 코드들을 보고 효율적으로 수정할 수 있어야한다..



1. `	`javascript의 String

`	`""과 ''을 구분하지 않는다



`	```백틱 기호를 사용해서 문자열 중간에 ${}로 변수를 넣을 수 있다.

`	`그리고 단락이 변경되는 enter도 적용된다.

`	`(요걸 템플릿 리터럴 이라고 한다.)	

`	`""나 '' 에서 줄바꿀때는 특수기호를 사용한다 (ex \n 등 여러 기능을 하는 특수기호들이 있다.)

`	`텍스트형식의 데이터는 길이에 상관없이 문자열 형태로 저장된다!

`	`문자열을 비교할땐 알파벳 순서를 기준으로 글자끼리 비교를 한다!

`	`(소문자는 대문자 보다 항상 큼/but 발음구별기호가 붙은 문자는 알파벳 순서기준을 따르지 않음(ex Ö 이런거))

`	`js내의 모든 문자열은 UTF-16을 사용해 인코딩 된다.

`	`(UTF-16이란?)

`	`UTF-8 : 1~4바이트를 이용

`	`UTF-16 : 2~4바이트를 이용

`	`UTF-8에서 3바이트로 표현되는 문자들은 UTF-16에선 2바이트로 표현되므로 문서가 3바이트에 해당할경우 UTF-16을 선택하면 효율적

`	`모든 글자가 숫자형식의 코드와 매칭이 된다. (ex : z.codePointAt = 122 / Z.codePointAt = 90)	



`	`서로게이트 쌍?

`	`(자주 사용되는 글자들은 2바이트 코드를 가지고 있는데 2바이트로는 현존하는 모든 기호를 표현하기 어려워서

`	`사용빈도가 낮은 기호를 서로게이트쌍(surrogate pair)이라 부르며 2바이트 글자들의 쌍을 사용해 인코딩하는것)



`	`.length 프로퍼티로 글자수를 찾을 수 있다

`	`(활용법:아이디나 비밀번호의 길이를 조절하게 하는 회원가입방법)



`	`[0] 인덱싱을 사용하여 해당 글자 위치를 변경하거나 할 수 있다.

`	`(0부터 시작하기에 7글자면 6개의 위치)



1. `	`javascript의 delete

`	`delete 연산자는 객체의 속성을 제거할 수있다. delete 변수.속성값; 으로 사용

`	`제거가 되면(반환되는값)은 true로 리턴된다.

`	`존재하지 않는 속성이라도 true를 리턴한다.

`	`단, 엄격모드(use strict)에서 속성이 자신의 속성이며, 설정 불가능한 경우 타입에러를 뱉는다..



`	`그리고 var로 선언되었을경우에는

`	`--글로벌 스코프의 어떤 함수도 삭제 할 수 없다

`	`--단 오브젝트의 속성으로 있는 함수인 경우(글로벌스코프 제외) 삭제가능



`	`let,const로 선언한 속성은 어떤 스코프에 있던간에 삭제 불가능

1. `	`function

`	`함수란 input(파라미터)로 받아와서 코드를 실행하고 output으로 리턴값을 출력하는것

`	`함수에는 선언과 호출이 있다.

`	`한개의 함수는 한가지의 일만 하도록 설정하기

`	`장점 : 긴 코드를 하나로 압축시킬수 있고 재사용이 가능하다

`	`함수도 js의 자료형중 하나이다.(object)

`	`함수 선언식 (ex) function 함수명 (매개변수:파라미터){실행할 함수코드}

`	`함수 표현식 (변수로 선언해서 함수를 사용하는 방법 ex) const 함수 = function (){})으로 사용할때는 보통 함수명을 생략해서 익명함수로 활용



`	`유용할것 같은 기능

`	`1. default

`	`-> 파라미터를 정의 해주지 않을때 기본값으로 출력될것을 정의해줄수 있다.

`	`function message(message, name = 'unknown'){

`	`console.log(`${message} by ${name}`)}

`	`message('Hi!') 일때 디폴트 값 출력해줌



`	`2. Rest 파라미터

`	`function 함수 (...a){

`	`for(let i = 0; i <a.length; i++)} 배열형태의 파라미터로 전달 +배열일때 for Each 사용법!



`	`3. IIFE (Immediately Invoked Function Expression)

`	`함수를 ()로 묶고 ();로 바로 호출할수 있다.(요즘엔 잘 안쓴다함)

`	`ex) (function hello(){console.log('hello')}) (); 로 바로출력

1. `	`scope

`	`스코프란 범위, 즉 변수에 접근 가능한 범위를 뜻함

`	`함수 블록 바깥에 선언되면 전역 스코프

`	`함수 블록 안에 선언되면 지역 스코프

`	`다이나믹 스코프(동적스코프)<->스태틱(랙시컬)스코프(정적 스코프)

`	`js는 정적 스코프

`	`대부분의 c-family lang은 블록 레벨 스코프를 따른다.

`	`블록레벨 스코프란? 코드 블록({...})내에서만 유효한 스코프를 의미

`	`유효하다? 참조(접근)할수 있다는 뜻

`	`js 에서는 let,const가 블록 레벨 스코프를 따른다.

`	`즉 블록 안에서만 호출 가능

`	`js는 함수레벨 스코프 (function-level scope)를 따른다.

`	`함수레벨 스코프란? 함수 코드 블록 내에서 선언된 변수는 함수 코드 블록 내에서만 유효하다

`	`함수 외부에서는 유효x(참조x)

`	`함수 영역에서 전역변수를 참조 할 수 있을때 는 전역변수의 값도 변경 할 수 있다.

`	`보통 var로 선언하면 함수레벨 스코프를 따른다.

`	`But!! ES6에서 도입된 let/const 사용하면 블록 레벨 스코프 사용가능!

`	`js 스코프엔 스코프 체인이라는것이 존재

`	`현재 스코프에 해당 변수가 없으면 상위 스코프로 가서 찾는것

`	`closure랑 연결?



1. `	`hoisting

`	`변수의 선언과 초기화를 분리 하고 선언만 코드의 최상단으로 옮겨진것 같은 현상

`	`js 는 초기화를 제외한 선언만 호이스팅 but var로 선언해줘야함 !

`	`var로 선언한 변수의 경우 호이스팅 시 undefined로 변수를 초기화

`	`반면 let,const로 선언한 변수의 경우 호이스팅 시 변수를 초기화 하지 않는다.

`	`그래서 변수 초기화 전에 읽는 코드가 먼저 나오면 예외 발생!

`	`(요런 현상 <=>선언된 변수를 선언문 이전에 참조하는 현상을 TDZ(일시적 사각지대)에 빠진거라 한다.)

`	`(초기화 전에 접근하면 ReferenceError = let/const을 사용할거면 실행되는 코드와 초기화 되는 순서를 변경해주거나

`	`아니면 var를 사용하면 해결될듯싶다.)



`	`추가정보 - 변수는 3단계에 걸쳐 생성된다.

`	`(1단계: 선언단계(스코프가 참조) => 2단계: 초기화단계(요상태에서 undefined) => 3단계: 할당단계(undefined에 실제 값 할당))

1. `	`익명함수(람다함수)

`	`함수명 대신 변수명에 함수 코드를 저장하는 구현 방식

`	`호출 시 변수명을 함수명처럼 사용한다.

`	`디버깅할때 어떤 함수가 잘못되었는지 찾기 위해선 함수명을 선언하는게 나을거 같다.	

`	`단점 : 호이스팅이 적용되지 않는다.

`	`arrow function

`	`항상 이름이 없는 함수

`	`간결하게 쓸 수 있는 장점 (생략 할 수 있는 부분이 많다.)

`	`배열이나 리스트 볼때 편하다.

1. `	`closure

`	`자식의 함수가 부모함수로 접근이 가능한 형태?

`	`부모 함수 안에서 자식함수를 선언하면 자식함수를 어디에서 호출하더라도 자식함수안에서 부모함수의 변수에 접근 가능

`	`var increase = (function () {

`	 `// 카운트 상태를 유지하기 위한 자유 변수

`	`var counter = 0;

`	 `// 클로저를 반환

`	`return function () {

`	`return ++counter;

`	 `};

`	`}());

