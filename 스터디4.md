1. `	`constructor

`	`컨스트럭터는 오브젝트를 뽑아낼 수 있는 기계같다.

`	`문법은 함수만들듯이 function 함수명(){} 만들지만 함수명 첫글자를 대문자로 해서 이건 컨스터럭터다 라고 하는게 국룰

`	`또는 class 대문자함수명 { constructor(){ this~ } }로도 만드는데 차이점은 무엇일까

`	`ES6에서 클래스 문법이 추가되면서 생김. 추가기능 알아봐야할것.(IE에서 동작안할듯)

`	`또한 어떻게 만들든 사용은 선언을 해줌과 동시에 new 컨스트럭터(); 로 할당해주면 함수복사 완료

`	`핵심은 this 키워드를 사용한다는점(this 는 instance이다.)



1. `	`new



1. `	`prototype

`	`js 에만 있는 상속을 구현하는 문법(부모,자식) 부모의 유전자를 물려 받는느낌

`	`constructor를 만들면 prototype 이라는 공간이 생긴다.(함수에만 프로토타입있음)

`	`컨스트럭터를 만들면 부모가 되고 해당 값을 할당받은 변수들은 자식이 되는데

`	`컨스트럭터에 프로토 타입으로 프로퍼티를 추가해주면 자식들한테도 추가되어진다.!!

`	`(근데 여기서 추가는 자식한테서 직접적으로 들어가는게 아니라 부모에게 들어간것)

`	`(js는 무언가 출력요청을 했을때 요청을 받은 곳에서 일단 찾고! 없으면 부모한테가서 있는지 찾아서 출력해주는 구조)

`	`그래서! array자료형을 만들때 sort() map() 이런걸 정의해주지 않았는데 쓸 수 있었던것은!!

`	`내가 쓰고자하는 array구조의 부모는 항상 new Array(~~)로 만들어졌고!

`	`Array.prototype 해보면 안에 다 유전자가 박혀있다..

`	`자식들이 값을 직접 소유하고싶게 만들고 싶으면 컨스트럭터

`	`부모만 가지고 그걸 참조할수 있게 만들고 싶으면 프로토타입

`	`\* \_\_proto\_\_로 부모 유전자를 조회하거나 가져올수도 있다
